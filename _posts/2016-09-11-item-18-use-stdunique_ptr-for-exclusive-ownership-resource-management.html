---
layout: post
title: 'Item 18: Use std::unique_ptr for exclusive-ownership resource management'
date: 2016-09-11 22:12:48.000000000 -04:00
type: post
published: true
status: publish
categories: []
tags:
- modernc++
meta:
  _rest_api_published: '1'
  _rest_api_client_id: '-1'
  _publicize_job_id: '26725681239'
author:
  login: cowboybebop98
  email: xiongm@gmail.com
  display_name: cowboybebop98
  first_name: ''
  last_name: ''
---
<p>unique_ptr is a move-only type, because unique_ptr embodies a exclusive ownership semantics, meaning that you can not have two unique_ptr point to the same underlying object. As a result, unique_ptr cannot be copied, i.e. copy constructor/copy assignment constructor are not defined for unique_ptr.</p>
{% highlight cpp %}
using namespace std;
unique_ptr<MyObject> a(new MyObject());
unique_ptr<MyObject> b(a); // error! can not be copy constructed
unique_ptr<MyObject> c = move(a); // OK, but now a can not be used any more
{% endhighlight %}
<p>unique_ptr by default is the same size as raw pointer, thus using unique_ptr incur no difference than using a raw pointer.</p>
<p>A good use of unique_ptr is simple factory function that initializes and returns unique_ptr. The caller will manage the lifecycle of the object.</p>
<p>[code language="cpp"]<br />
class Piece {<br />
 ...<br />
};<br />
class Knight : public Piece {<br />
 ...<br />
};<br />
class Bishop: public Piece {<br />
 ...<br />
};<br />
// variadic template, C++ 11's new feature to support arbitrary number<br />
// of template arguments with arbitrary type<br />
typename &lt;typename... Arguments&gt;<br />
unique_ptr&lt;Piece&gt;<br />
create_piece(const string &amp; name, Arguments&amp;&amp;... args)<br />
{<br />
    unique_ptr&lt;Piece&gt; piece;<br />
    if (name == &quot;Knight&quot;)<br />
    {<br />
       piece.reset(new Knight(forward&lt;Arguments&gt;(args)...));<br />
    } else if (name == &quot;Bishop&quot;)<br />
    {<br />
       piece.reset(new Bishop(forward&lt;Arguments&gt;(args)...));<br />
    } else<br />
    {<br />
       throw std::runtime_error(&quot;unknown type&quot;);<br />
    }<br />
    return piece;<br />
}<br />
[/code]</p>
<blockquote>
<h3>It is easy to convert unique_ptr to shared_ptr, thus making unique_ptr ideal for factory function since you have two options(unique_ptr or shared_ptr)</h3>
</blockquote>
<p>Notes:</p>
<p>Q: Why auto_ptr can't be used with STL but unique_ptr can?</p>
<p>A: elements in STL container need to be copy constructible and copy assignable, but copying auto_ptr from a STL container will set it to null, thus invalidating this guarantee. unique_ptr implements move semantics, it will use move instead of copy.</p>
<p>&nbsp;</p>
