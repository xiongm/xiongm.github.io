---
layout: post
title: Item 1 Understand template type deduction
date: 2016-08-28 04:35:20.000000000 -04:00
type: post
published: true
status: publish
categories: []
tags:
- C++
- modernc++
meta:
  _publicize_job_id: '26222740079'
  _rest_api_published: '1'
  _rest_api_client_id: '-1'
author:
  login: cowboybebop98
  email: xiongm@gmail.com
  display_name: cowboybebop98
  first_name: ''
  last_name: ''
---
<p>Function template looks like the following</p>
<p>[code language="cpp"]<br />
template &lt;typename T&gt;<br />
void f(ParamType param)<br />
[/code]</p>
<p>A call to the function looks like this</p>
<p>[code language="cpp"]<br />
f(expr)<br />
[/code]</p>
<p>During compilation, compiler use expr to deduce types for both T and ParamType and they are usually different. Following are some of the key knowledge points with examples. The quoted messages are from Modern Effective C++ by scott meyers</p>
<blockquote>
<h3><em>During template type deduction, arguments that are references are treated as non reference</em></h3>
</blockquote>
<p>[code language="cpp"]<br />
template &lt;typename T&gt;<br />
void f(T &amp; param)</p>
<p>int x = 10;<br />
int &amp; y = x;<br />
const int z = 15</p>
<p>f(x) // T is int, param's type is int &amp;<br />
f(y) // T is int, param's type is int &amp;.<br />
// Note that y's reference-ness is ignored<br />
f(z) // T is const int, param's type is const int &amp;<br />
[/code]</p>
<blockquote>
<h3>When deducing types for universal reference parameters, lvalue arguments getÂ special treatment.</h3>
</blockquote>
<p>[code language="cpp"]<br />
template &lt;typename T&gt;<br />
void f(T &amp;&amp; param)    // universal reference, yes it looks just like rvalue reference</p>
<p>int x = 10;<br />
const int y = x;</p>
<p>// x is a lvalue, when deduced, T is translates to int &amp;<br />
// so is param's type<br />
// the only situation in which a expr is deduced to a<br />
// reference type<br />
f(x)<br />
f(y) // similarly, T is const int &amp;, so is param's type<br />
[/code]</p>
<blockquote>
<h3>When deducing types for by-value parameters, const and/or volatile arguments<br />
are treated as non-const and non-volatile.</h3>
</blockquote>
<p>[code language="cpp"]<br />
template &lt;typename T&gt;<br />
void f(T param) // pass by value</p>
<p>int x = 10;<br />
const int y = x;</p>
<p>f(x) // T is int, so is param's type<br />
f(y) // T is int, so is param's type, notice how const is ignored<br />
[/code]</p>
